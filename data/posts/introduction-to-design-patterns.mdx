---
title: Introduction to Design Patterns
description: Understanding Design Patterns in Software Development
category: Design Pattern
thumbnail: /image/introduction-to-design-patterns.jpg
createdAt: 2025-03-06
featured: false
---

---

## # 목차

- [# 소개](#-소개)
- [# 디자인 패턴의 주요 목적과 분류](#-디자인-패턴의-주요-목적)
- [# 디자인 패턴의 분류](#-디자인-패턴의-분류)
- [# 생성 패턴](#-생성-패턴)
- [# 구조 패턴](#-구조-패턴)
- [# 행위 패턴](#-행위-패턴)
- [# 마무리](#-마무리)

---

## # 소개

[# 목차](#-목차)

_디자인 패턴<sup>(Design Pattern)</sup>은 소프트웨어 설계에서 자주 발생하는 문제를 해결하기 위한 재사용 가능한 솔루션입니다._ 간단히 말해, 특정 상황에서 효과적으로 문제를 해결할 방법을 미리 정의한 것입니다. 특정 문제를 해결하기 위한 아이디어나 모범 사례로, 코드의 재사용성을 높이고 유지보수를 쉽게 만들 수 있습니다. _디자인 패턴은 주로 객체 지향 프로그래밍<sup>(OOP)</sup>에서 주로 사용됩니다._ OOP는 객체 간의 상호작용과 관계를 중심으로 설계되기 때문에, 디자인 패턴이 객체와 클래스 간의 효율적인 상호작용을 돕습니다. 반면, _함수형 프로그래밍<sup>(FOP)</sup>에서는 상태 변경을 최소화하고 순수 함수 중심의 접근을 선호하므로, OOP에서 사용하는 디자인 패턴들이 그대로 적용되기 어려운 경우가 많습니다._ 따라서 디자인 패턴은 객체 지향 설계의 효율성과 유지보수성을 높이는 데 중요한 역할을 합니다.

---

## # 디자인 패턴의 주요 목적

[# 목차](#-목차)

- _문제 해결의 표준화_  
   자주 발생하는 문제를 해결하기 위한 표준화된 방법을 제공하여, 더 나은 소프트웨어를 만들 수 있게 합니다.

- _유지보수 용이성_  
  소프트웨어가 확장되거나 수정될 때, 이미 검증된 패턴을 사용하면 수정이 용이해집니다.

- _코드 재사용성_  
  이미 잘 설계된 패턴을 사용하여 코드를 재사용하고, 중복을 줄일 수 있습니다.

---

## # 디자인 패턴의 분류

[# 목차](#-목차)

디자인 패턴은 주로 _생성 패턴<sup>(Creational Patterns)</sup>, 구조 패턴<sup>(Structural Patterns)</sup>, 행위 패턴<sup>(Behavioral Patterns)</sup>_ 카테고리로 분류됩니다. 각 카테고리는 해결하려는 문제의 종류와 초점에 따라 구분되며, 특정 상황에서 어떻게 효과적으로 문제를 해결할 수 있는지에 대한 방법론을 제공합니다.

- _생성 패턴_  
  객체 생성과 관련된 문제를 다루며, 객체를 효율적이고 유연하게 생성하는 방법을 제시합니다.

- _구조 패턴_  
  클래스와 객체 간의 관계를 설계하는 데 중점을 두며, 시스템의 구조를 효율적이고 유연하게 구성할 수 있는 방법을 제공합니다.

- _행위 패턴_  
  객체 간의 상호작용과 책임 분배에 관한 문제를 해결하며, 객체들이 협력하는 방식과 알고리즘을 어떻게 캡슐화할지에 대한 해결책을 제시합니다.

이러한 분류를 통해 각 패턴이 어떤 문제를 해결하고자 하는지, 그리고 그 해결책이 어떤 방식으로 작동하는지를 명확히 알 수 있습니다.

---

## # 생성 패턴

[# 목차](#-목차)

생성 패턴은 객체를 생성하는 방식에 초점을 맞춘 패턴입니다. 객체 생성 과정에서 발생할 수 있는 유연성 부족이나 비효율성을 해결하고자 합니다. 간단히 말해, _객체를 효율적이고 유연하게 생성하는 방법에 대해 다룹니다._ 예를 들어, 특정 조건에 맞게 객체를 동적으로 생성하거나, 객체 생성에 대한 책임을 어떻게 분리할지 등을 해결하는 방식입니다.

주요 생성 패턴은 다음과 같습니다.

- _싱글톤 패턴 (Singleton Pattern)_  
  클래스의 인스턴스 *하나만 생성*하고, 이를 전역적으로 접근할 수 있도록 보장하는 패턴입니다. 시스템 내에서 유일한 객체를 만들어 공유해야 할 때 사용합니다. 예를 들어, 설정 관리, 데이터베이스 연결 등이 해당됩니다.

- _팩토리 메서드 패턴 (Factory Method Pattern)_  
  객체 생성의 책임을 *서브클래스<sup>(Subclass)</sup>에 위임*하는 방식입니다. 즉, 객체 생성의 방식을 서브클래스에서 정의하도록 하여, 클라이언트는 객체 생성 방법을 몰라도 되도록 합니다. 주로 객체 생성 방식을 변경하고자 할 때 유용하며, 생성할 객체를 결정하는 로직을 클라이언트 코드에서 분리합니다.

- _추상 팩토리 패턴 (Abstract Factory Pattern)_  
  관련된 객체를 *일관된 방식으로 생성*할 수 있는 인터페이스를 제공하는 패턴입니다. 복잡한 객체군을 생성할 때 사용되며, 시스템 내에서 다양한 관련 객체들을 *집합적으로 생성*해야 할 때 구체적인 객체 클래스를 지정하지 않고 인터페이스로 객체들을 다룰 수 있도록 합니다.

- _빌더 패턴 (Builder Pattern)_  
  복잡한 객체를 *단계별로 구성*하는 패턴입니다. 객체를 구성하는 과정과 객체의 표현을 분리하여, 동일한 구성 절차로 다양한 객체를 만들 수 있게 합니다. 복잡한 객체를 생성할 때 생성 과정의 순서를 유연하게 처리하여 객체를 구성하는 과정을 명확히 분리합니다.

- _프로토타입 패턴 (Prototype Pattern)_  
  객체를 *복사하여 새로운 객체를 생성*하는 패턴입니다. 기존 객체를 복제하는 방식으로 객체를 빠르게 생성합니다. 객체 생성의 비용이 매우 비쌌거나 복잡할 때, 이미 생성된 객체를 복제하여 새로운 객체를 빠르게 만드는 방법을 제공합니다.

---

## # 구조 패턴

[# 목차](#-목차)

구조 패턴은 객체와 클래스 간의 관계를 어떻게 설계하고 구성할 것인지에 초점을 맞춘 패턴입니다. 객체 간 관계를 최적화하고 복잡도를 감소시키는 이 패턴들은 _복잡한 시스템에서 클래스나 객체들이 효율적이고 유연하게 상호작용할 수 있도록 돕습니다._ 객체나 클래스들을 어떻게 조합할 것인지, 그리고 이들 간의 관계를 어떻게 정의할 것인지에 관한 해결책을 제시합니다.

주요 구조 패턴은 다음과 같습니다.

- _어댑터 패턴 (Adapter Pattern)_  
  서로 다른 인터페이스를 가진 클래스들을 *호환되게 연결*하는 패턴입니다. 기존 클래스를 수정하지 않고, 다른 시스템과 호환되도록 인터페이스를 변경합니다. 주로 다양한 인터페이스를 가진 객체들을 연결하거나, 기존 코드를 변경하지 않고 새로운 시스템과 호환되도록 할 때 사용됩니다.

- _브릿지 패턴 (Bridge Pattern)_  
  추상화된 인터페이스와 그 구현을 *분리하여 독립적으로 확장*할 수 있도록 하는 패턴입니다. 이 패턴은 구현 부분이 변경되어도 추상화 부분에 영향을 미치지 않도록 합니다. 브리지 패턴은 시스템의 복잡도를 줄이고, 추상화와 구현을 분리하여 서로 독립적으로 확장하는 용도로 사용됩니다.

- _컴포지트 패턴 (Composite Pattern)_  
  개별 객체와 복합 객체를 동일하게 다룰 수 있도록 _트리 구조_<sup>_(Tree Structure)_</sup>로 객체를 구성하는 패턴입니다. 복잡한 객체 구조를 단순화하거나 트리 구조로 객체들을 구성하여 부분 객체와 전체 객체를 동일하게 다룰 수 있도록 합니다.

- _데코레이터 패턴 (Decorator Pattern)_  
  기존 객체에 *동적으로 새로운 기능을 추가*하는 패턴입니다. 객체의 구조를 변경하지 않고, 객체에 새로운 기능을 추가할 수 있습니다. 객체의 기능을 확장하고자 할 때, 객체의 상태나 동작을 변경하지 않고 기능을 추가할 때 사용합니다.

- _퍼사드 패턴 (Facade Pattern)_  
  복잡한 시스템을 *단순한 인터페이스*로 감싸는 패턴입니다. 클라이언트가 복잡한 서브시스템을 직접 다루지 않고, 하나의 간단한 인터페이스를 통해 접근할 수 있게 합니다. 시스템의 복잡성을 감추고, 클라이언트가 시스템을 쉽게 사용할 수 있도록 합니다.

- _플라이웨이트 패턴 (Flyweight Pattern)_  
  객체의 *공유를 통해 메모리 사용을 최소화*하는 패턴입니다. 동일한 데이터나 상태를 가진 객체를 여러 번 생성 하는 대신, 공유하여 메모리 사용을 절감합니다. 주로 많은 객체가 비슷한 데이터를 공유하는 경우, 객체를 재사용하여 메모리 낭비를 줄이고 성능 최적화합니다.

- _프록시 패턴 (Proxy Pattern)_  
  실제 객체에 대한 접근을 *대리인 객체*가 제어하는 패턴입니다. 프록시는 실체 객체에 대한 접근을 제한하거나, 접근을 조정하는 역할을 합니다. 객체에 대한 접근을 제어하고, 그 객체의 생명주기를 관리하거나 성능 최적화를 할 때 사용됩니다.

---

## # 행위 패턴

[# 목차](#-목차)

행위 패턴은 _객체 간의 상호작용과 책임 분배에 초점을 맞춘 패턴입니다._ 이 패턴들은 객체들이 서로 어떻게 협력하고, 각 객체가 어떤 역할을 맡을지에 대한 규칙을 정의합니다. 또한, 알고리즘이나 요청 처리 방식과 같은 *행동을 캡슐화*하여 객체들이 직접적인 상호작용 없이도 협력할 수 있도록 합니다.

주요 행위 패턴은 다음과 같습니다.

- _옵저버 패턴 (Observer Pattern)_  
  객체의 상태 변화가 발생하면, 이를 *자동으로 다른 객체들에게 통지*하는 패턴입니다. 주로 _일대다_ 의존 관계에서 사용됩니다. 객체 간의 상태 변화를 다른 객체에 자동으로 전파하여, 의존성을 최소화하고 동기화된 업데이트를 제공합니다.

- _전략 패턴 (Strategy Pattern)_  
  다양한 알고리즘을 *캡슐화*하여 하나의 객체 내애서 동적으로 선택할 수 있도록 하는 패턴입니다. 알고리즘을 클래스 내애서 동적으로 선택할 수 있도록 하는 패턴입니다. 알고리즘을 클래스 내에서 변경할 수 있도록 하여, 클라이언트가 알고리즘을 쉽게 변경하거나 확장할 수 있도록 합니다.

- _커맨드 패턴 (Command Pattern)_  
  요청을 *객체로 캡슐화*하여, 요청의 수행자와 요청 자체를 분리하는 패턴입니다. 요청을 큐에 저장하거나 나중에 실행할 수 있게 합니다. 요청을 객체로 감싸고, 요청의 실행 시점과 요청을 분리하여 유연하게 처리할 수 있습니다.

- _템플릿 메서드 패턴 (Template Method Pattern)_  
  알고리즘의 _구조는 정의하되_, 알고리즘의 일부 단계를 *서브클래스에서 구현*하게 하는 패턴입니다. 알고리즘의 기본 구조를 정의하고, 세부적인 동작은 서브클래스에서 수정할 수 있도록하여, 코드 중복을 줄이고 확장성을 높입니다.

- _인터프리터 패턴 (Interpreter Pattern)_  
  언어의 문법을 *해석하고 실행*하는 패턴입니다. 주로 복잡한 언어나 규칙을 해석할 때 사용됩니다. 특정 언어나 표현식을 해석하여 실행 가능한 형태로 변환하는 작업을 캡슐화하여 효율적으로 처리할 수 있도록 합니다.

- _중재자 패턴 (Mediator Pattern)_  
  객체들이 서로 직접 통신하지 않고, _중재자를 통해_ 상호작용하는 패턴입니다. 중재자는 객체들 간의 의사소통을 조정하고, 객체들이 서로 의존하지 않도록 합니다. 주로 객체들 간의 의존성을 줄이고, 중재자를 통해 객체 간의 협력을 조정하여 시스템을 단순화합니다.

- _체온 오브 리스폰서빌리티 패턴 (Chain of Responsibility Pattern)_  
  요청을 여러 객체가 처리할 수 있도록 연결하여 처리하는 패턴입니다. 각 객체는 자신이 처리할 수 있는 요청만 처리하고, 나머지 요청은 다음 객체로 넘깁니다. 요청 처리 책임을 여러 객체에 분산시켜, 처리할 수 있는 객체가 이를 처리하도록 합니다. 이로 인해 각 객체의 책임이 명확해지고, 유연하게 요청을 처리할 수 있습니다.

- _비지터 패턴 (Visitor Pattern)_  
  객체의 _구조를 변경하지 않고_ 객체의 데이터를 추가하거나 변경할 수 있도록 하는 패턴입니다. 객체의 구조를 변경하지 않고 새로운 동작을 추가할 수 있도록 하여, 시스템의 확장성을 높입니다.

---

## # 마무리

[# 목차](#-목차)

디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제에 대한 *효율적이고 검증된 해결책*을 제공합니다. 적절히 활용하면 코드의 _재사용성_, _유지보수성_, _확장성을 높이고_, 개발 속도와 품질을 개선하는 데 도움이 됩니다. 또한, 디자인 패턴은 팀 내에서 일관된 코드를 유지하고, _복잡한 시스템을 더 유연하게_ 설계할 수 있게 합니다.

_# references_
