---
title: Why Using Index as Key in React Is a Bad Idea
description: The Role of Key and the Importance of Unique Keys
category: React
thumbnail: /image/posts/why-using-index-as-key-in-react-is-a-bad-idea.jpg
createdAt: 2025-03-15
featured: false
---

---

## 리액트에서 key의 역할과 고유한 key의 중요성

리액트<sup>(React)</sup>에서 반복문을 사용할 때 `key`는 매우 중요한 역할을 합니다.
`key`는 리액트가 DOM<sup>(Document Object Model)</sup>을 효율적으로 업데이트하는 데 도움을 주며, 애플리케이션의 성능을 최적화하는 데 중요한 요소입니다.
이번 포스트에서는 리액트에서 `key`의 역할과 `key`가 고유해야 하는 이유에 대해 살펴보고,
`key`를 어떻게 선택해야 하는지에 대해 설명하겠습니다.

---

## # 목차

- [# 리액트의 컴포넌트 반복문](#리액트의-컴포넌트-반복문)
- [# key를 index로 사용하는 것의 문제점](#key를-index로-사용하는-것의-문제점)
- [# 컴포넌트 반복문에서 key가 고유해야 하는 이유](#컴포넌트-반복문에서-key가-고유해야-하는-이유)
- [# key를 선택할 때 고려해야 할 사항](#key를-선택할-때-고려해야-할-사항)
- [# 마무리](#마무리)

---

## 리액트의 컴포넌트 반복문

[# 목차](#-목차)

리액트에서는 배열을 렌더링할 때 `Array.prototype.map` 메서드를 이용하여 컴포넌트를 반복적으로 렌더링하는 경우가 많습니다.
이런 경우, 컴포넌트에 `key` 속성<sup>(property)</sup>를 설정하지 않으면 리액트가 각 항목을 식별하지 못해 성능 문제가 발생할 수 있습니다.
예를 들어, 배열에서 각 항목을 출력하는 간단한 코드 예시는 다음과 같습니다.

```javascript
const fruits = ["Apple", "Banana", "Cherry"];

const FruitList = () => (
  <ul>
    {fruits.map((fruit) => (
      <li>{fruit}</li> // Warning
    ))}
  </ul>
);
```

위 코드에서 리액트는 각 항목을 식별할 방법이 없기 때문에 반복되는 컴포넌트들을 효율적으로 업데이트할 수 없습니다.
이로 인해 개발자는 `Warning: Each child in a list should have a unique "key" prop.` 문구의 경고를 받게 되며,
고유한 `key`를 설정할 것을 권장받습니다. 이러한 문제를 해결하기 위해서는 각 항목에 고유한 `key` 속성을 설정해야 합니다.

---

## 리액트에서의 key의 역할

[# 목차](#-목차)

_`key`는 리액트에서 반복되는 각 컴포넌트를 고유하게 식별할 수 있게 해주는 속성입니다._
배열을 렌더링할 때 `key`를 설정하면, 리액트는 항목이 변경되었을 때 어떤 항목이 수정되었는지 정확하게 추적할 수 있습니다.
이를 통해 리액트는 효율적으로 렌더링을 최적화하고, 불필요한 DOM 업데이트를 방지할 수 있습니다.

- _고유 식별_  
  `key`는 각 항목을 고유하게 식별하여, 리액트가 항목을 비교하고 업데이트할 때 정확하게 처리할 수 있도록 합니다.

- _리렌더링 최적화_  
  `key`를 통해 리액트는 항목의 변경 사항만 추적하고, 불필요한 리렌더링을 방지합니다. 예를 들어, 배열에 항목을 추가하거나, 삭제할 때,
  `key`를 사용하여 리액트는 실제로 변경된 부분만 갱신할 수 있습니다.

```javascript
const fruits = ["Apple", "Banana", "Cherry"];

const FruitList = () => (
  <ul>
    {fruits.map((fruit, index) => (
      <li key={index}>{fruit}</li>
    ))}
  </ul>
);
```

이 코드에서 `key={index}`를 사용하여 개발자는 더 이상 `Warning` 경고 메시지를 받지 않지만,
리액트는 각 항목을 고유하게 구별할 수 없게 됩니다. _그 이유는 `index` 값이 배열의 순서에 의존하기 때문입니다._
쉽게 말해, 배열의 항목이 동적으로 추가되거나 삭제될 때 `index` 값이 변경된 항목의 순서에 따라 달라진다는 것입니다.
리스트 항목이 추가되거나 삭제되면 `index` 값이 변경되는데, 이로 인해 리액트는 이전 항목과 새 항목을 정확히 구별할 수 없게 됩니다.
그 결과, 성능 최적화가 이루어지지 않거나, 개발자의 의도와는 다른 렌더링이 발생할 수 있습니다.

---

## 컴포넌트 반복문에서 key가 고유해야 하는 이유

[# 목차](#-목차)

리액트는 가상 DOM을 사용하여 UI를 효율적으로 업데이트합니다.
가상 DOM에서는 실제 DOM과 비교하여 변경된 부분만 업데이트하는 방식으로 성능을 최적화합니다.
이때 `key`는 리액트가 어떤 항목이 변경되었는지를 빠르게 식별할 수 있도록 도와줍니다.
즉, _`key`가 고유하지 않으면 리액트는 변경된 항목을 잘못 처리할 수 있습니다._

### 가상 DOM과 Diffing 알고리즘

리액트는 상태 변경 시 새로운 가상 DOM을 생성하고, 이를 이전 가상 DOM과 비교하여 차이점을 계산합니다.
이 과정을 *Diffing*이라고 하며, 이때 각 항목의 `key`를 활용하여 어떤 항목이 추가되거나 삭제되었는지를 파악합니다.
만약 `key`가 고유하지 않다면, 리액트는 변경된 항목을 정확하게 식별하지 못하고 잘못된 렌더링이 발생할 수 있습니다.

```javascript
const fruits = ["Apple", "Banana", "Cherry"];

const FruitList = () => (
  <ul>
    {fruits.map((fruit) => (
      <li key={fruit}>{fruit}</li>
    ))}
  </ul>
);
```

위 코드에서는 `key={fruit}`를 사용하여 각 항목을 고유하게 식별합니다.
현재 배열에서는 `fruit`의 값이 고유하므로, 리액트는 각 항목을 정확하게 구별할 수 있습니다.
다만, 이 방법은 `fruits` 배열에 동일한 항목이 없어야 한다는 전제 조건이 필요합니다.
만약 배열에 중복된 값이 있다면, `key`가 고유하지 않게 되어 리액트가 항목을 올바르게 추적하지 못할 수 있습니다.

---

## key를 선택할 때 고려해야 할 사항

[# 목차](#-목차)

리액트에서 `key`를 선택할 때는 몇 가지 중요한 사항을 고려해야 합니다.
잘못된 `key`를 사용하면 리렌더링 성능이 떨어지고, UI가 예기치 않게 변경될 수 있습니다.

- _고유한 값 사용_  
  항목에 고유한 "ID"가 있다면 그 값을 `key`로 사용하는 것이 이상적입니다.
  예를 들어, 데이터베이스에서 받아온 고유한 "ID" 또는 "UUID"<sup>(Universally Unique Identifier)</sup>를 사용할 수 있습니다.

- _`index` 사용 피하기_  
  배열의 `index`는 항목의 순서가 변경될 때마다 값이 달라지므로 `key`로 사용하는 것은 피해야 합니다.
  `index`를 `key`로 사용하면 리액트가 항목을 제대로 식별하지 못할 수 있습니다.

- _성능 최적화_  
  `key`를 선택할 때는 성능 최적화를 고려하여, 항목이 동적으로 추가되거나 삭제되는 경우에도 `key`가 변경되지 않도록 해야 합니다.

```javascript
const fruits = [
  { id: 1, name: "Apple" },
  { id: 2, name: "Banana" },
  { id: 3, name: "Cherry" },
];

const FruitList = () => (
  <ul>
    {fruits.map((fruit) => (
      <li key={fruit.id}>{fruit.name}</li>
    ))}
  </ul>
);
```

위 코드에서는 각 항목에 고유한 `id`를 `key`로 사용하고 있습니다.
이렇게 고유한 값을 `key`로 설정하면, 항목의 순서가 변경되거나 항목이 삭제되더라도 리액트는 변경 점을 정확하게 추적하고,
효율적으로 렌더링을 최적화할 수 있습니다.

---

## 마무리

[# 목차](#-목차)

리액트에서 `key`는 단순히 배열을 렌더링할 때의 성능 최적화만을 위한 것이 아닙니다.
`key`는 각 항목을 정확하게 식별하고, 리렌더링 성능을 최적화하며, 상태 업데이트가 정확히 처리되도록 돕습니다.
`key`를 올바르게 사용하는 것은 애플리케이션의 효율성을 높이고, 예기치 않은 UI 문제를 방지하는 데 매우 중요합니다.
리액트에서 `key`를 사용할 때는 각 항목을 고유하게 식별할 수 있는 값을 선택하고, 특히 `index`를 `key`로 사용하지 않도록 주의해야 합니다.
이를 통해 리액트의 성능을 최적화하고, 안정적인 애플리케이션을 구축할 수 있습니다.

_# references_
