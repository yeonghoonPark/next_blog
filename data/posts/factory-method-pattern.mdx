---
title: Factory Method Pattern
description: Understanding the Factory Method Design Pattern
category: Design Pattern
thumbnail: /image/posts/factory-method-pattern.jpg
createdAt: 2025-04-13
featured: false
---

---

## # 목차

- [# 팩토리 메서드 패턴이란](#-팩토리-메서드-패턴이란)
- [# 팩토리 메서드 패턴의 자바스크립트 구현](#-팩토리-메서드-패턴의-자바스크립트-구현)
- [# 팩토리 메서드 패턴의 장점과 단전](#-팩토리-메서드-패턴의-장점과-단점)
- [# 팩토리 메서드 패턴의 단점 대체 방안](#-팩토리-메서드-패턴의-단점-대체-방안)
- [# 팩토리 메서드 패턴의 사용 사례](#-팩토리-메서드-패턴의-사용-사례)
- [# 마무리](#-마무리)

---

## # 팩토리 메서드 패턴이란

[# 목차](#-목차)

팩토리 메서드 패턴<sup>(Factory Method Pattern)</sup>은 디자인 패턴의 생성 패턴으로 분류되며,
객체 생성 로직을 서브클래스로 분리해 객체 생성을 캡슐화하는 디자인 패턴입니다.
즉, _객체를 생성하는 책임을 상위 클래스가 아닌 하위 클래스에 위임함으로써, 객체 생성 방식과 사용하는 코드를 분리한 것입니다._
쉽게 말하면, 객체를 직접 `new` 키워드를 이용하여 생성하지 않고, 어떤 객체를 생성할지는 하위 클래스가 결정하는 방식입니다.
팩토리 메서드 패턴은 _객체 생성 로직이 복잡하여 객체를 생성하는 코드와 사용하는 코드를 분리하여 코드 확장성을 높이고 싶을 때 유용합니다._

---

## # 팩토리 메서드 패턴의 자바스크립트 구현

[# 목차](#-목차)

자바스크립트에서 팩토리 메서드 패턴을 구현하는 예제입니다.
예를 들어, 운영체제에 따라 스타일이 다른 버튼을 보여줘야 하는 UI 라이브러리를 만든다고 가정해 봅시다.
Windows에서는 파란색 둥근 버튼, Mac에서는 빨간색 사각 버튼을 렌더링해야 한다면,
버튼의 생성 로직을 조건문으로 계속 바꾸는 대신, 팩토리 메서드 패턴을 사용해 생성 책임을 하위 클래스에 위임할 수 있으며,
이 구조를 통해 코드의 유연성과 확장성을 높일 수 있습니다.

### 1. 제품 (Product)

```javascript
// 1. Product
class Button {
  render() {
    throw new Error("render() must be implemented");
  }
}
```

위의 `Button` 클래스는 공통 인터페이스(추상 클래스) 역할을 합니다.
핵심은 `render()` 메서드가 공통 인터페이스의 일부이지만, 구체적인 구현은 서브클래스에서 하도록 강제하는 점입니다.
공통 인터페이스로 사용할 버튼을 생성하였으니, Windows와 Mac에서 각 사용할 구체적인 제품을 정의하도록 하겠습니다.

### 2. 구체적인 제품 (Concrete Products)

```javascript
// 2. Concrete Products
class WindowsButton extends Button {
  render() {
    return "Round blue button";
  }
}

class MacButton extends Button {
  return() {
    return "Square red button";
  }
}
```

운영체제에 따라 다르게 구현된 버튼 클래스입니다.
`WindowsButton`과 `MacButton` 클래스는 각각 `Button` 클래스에서 상속받은 `render()` 메서드를 오버라이드하여,
자신에게 맞는 출력 또는 동작을 수행합니다.
이제 운영체제에 따라 어떤 버튼을 생성할지 구체적인 제품이 완성되었으니,
사용자와 운영체제 간의 상호작용에 필요한 버튼(객체)을 생성하는 역할인 상위 클래스(창조자)를 정의하도록 하겠습니다.

### 3. Creator (창조자)

```javascript
// 3. Creator
class Dialog {
  createButton() {
    throw new Error("createButton() must be implemented");
  }

  renderDialog() {
    const button = this.createButton();
    button.render();
  }
}
```

위에서 `Dialog` 클래스에서 정의된 `createButton()`이 팩토리 메서드입니다.
이 메서드는 하위 클래스에서 실제로 어떤 버튼을 만들지를 결정하게 됩니다.
`renderDialog()` 메서드는 클라이언트에서 사용하는 코드이지만,
구체적으로 어떤 버튼을 쓰는지 클라이언트에서 모르더라도 상관없도록 설계되어 있습니다.
쉽게 말하면, _`Dialog`는 상위 클래스로 객체를 생성하는 책임을 갖지만, 구체적으로 어떤 객체를 만들지는 모르며 이를 하위 클래스에 위임합니다._
이제 실제 어떤 버튼(객체)을 생성할지 결정하는 하위 클래스(구체적인 창조자)를 정의하도록 하겠습니다.

### 4. Concrete Creator (구체적인 창조자)

```javascript
// 4. Concrete Creator
class WindowsDialog extends Dialog {
  createButton() {
    return new WindowsButton();
  }
}

class MacDialog extends Dialog {
  createButton() {
    return new MacButton();
  }
}
```

`WindowsDialog`와 `MacDialog` 클래스는 `Dialog`라는 상위 클래스에서 `createButton()`을 상속받아, 메서드를 구체적으로 구현합니다.
이 메서드는 각 운영체제에 맞는 버튼 객체(`WindowsButton`, `MacButton`)를 생성하여 반환합니다.
이를 통해, 버튼 생성 방식이 각 하위 클래스 안에 캡슐화되므로,
상위 클래스인 `Dialog`의 `renderDialog()` 메서드는 변경 없이 그대로 재사용할 수 있습니다.
즉, 상위 클래스는 버튼이 어떻게 구체적으로 만들어지는지 모른 채, 단지 `createButton()`만 호출하면 버튼을 생성할 수 있습니다.
이 구조는 재사용성과 확장성에 높은 이점을 가집니다. 예를 들어, 새로운 운영체제에 Linux가 추가된다고 가정한다면,
구체적인 제품에 `LinuxButton` 클래스와 실제 객체 생성을 담당하는 하위 클래스(구체적인 창조자)에 `LinuxDialog` 클래스만 추가하기만 하면 되며,
클라이언트 코드를 수정할 필요 없이 기존 구조에서 그대로 적용할 수 있습니다.

### 5. 사용 예시 (클라이언트 코드)

```javascript
const windowsDialog = new WindowsDialog();
windowsDialog.renderDialog(); // 'Round blue button'
```

클라이언트는 `WindowsDialog` 또는 `MacDialog` 중 운영체제에 따라 어떤 버튼을 생성할지만 결정하면 됩니다.
버튼이 실제로 어떤 방식으로 구현되는지, 어떤 클래스를 통해 생성되는지 몰라도 되며 정의되어 있는 상위 클래스를 참조하여 호출하기만 하면 됩니다.
덕분에 클라이언트 코드는 `createButton()`이나 `new WindowsButton()` 같은 _클래스의 구체적인 객체 생성 로직에 의존하지 않게 됩니다._
이를 _느슨한 결합_<sup>_(Loose Coupling)_</sup>이라고 하며 의존성이 줄어들수록 코드의 재사용성, 유지보수성, 확장성이 높아집니다.

---

## # 팩토리 메서드 패턴의 장점과 단점

[# 목차](#-목차)

### 팩토리 메서드 패턴의 장점

#### 1. 객체 생성 코드와 사용 코드의 분리

- 클라이언트는 어떤 클래스의 인스턴스를 생성할지 알 필요가 없습니다.
  팩토리 메서드 패턴 덕분에 객체 생성 로직이 하위 클래스에 캡슐화되어 있어, 클라이언트는 상위 클래스만 알고 있으면 됩니다.
  예를 들어, `Dialog` 클래스를 사용하지만, 실제 어떤 버튼이 생성되는지는 `WindowsDialog` 또는 `MacDialog`가 알아서 처리하므로,
  클라이언트는 `Dialog`만 참조하여 호출하면 됩니다.

#### 2. 확장성 증가

- 새로운 제품을 추가하려면 기존 코드를 수정할 필요 없이 새로운 하위 클래스만 추가하면 됩니다.
  예를 들어, 새로운 운영체제인 Linux가 추가 될 때, `LinuxButton`과 `LinuxDialog` 클래스만 새로 구현하면 되고,
  기존 `WindowsDialog`와 `MacDialog`는 수정할 필요 없이 그대로 유지됩니다.

#### 3. 코드 재사용성 증가

- 공통된 로직 `renderDialog()`는 상위 클래스인 `Dialog`에서 처리하고,
  각 운영체제에 특화된 부분인 `createButton()` 메서드는 하위 클래스에서 구현합니다.
  이렇게 공통된 부분은 상위 클래스에서 재사용하고, 변화하는 부분은 하위 클래스에서만 처리되기 때문에 중복을 줄이고, 재사용성을 높일 수 있습니다.

#### 4. OCP(개방/패쇄 원칙) 만족

- OCP<sup>(Open/Closed Principle)</sup>는 "소프트웨어는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다"는 원칙입니다.
  팩토리 메서드 패턴은 이 원칙을 잘 만족시킵니다. 새로운 제품을 추가할 때는 기존 코드를 변경하지 않고, 새로운 클래스만 추가하면 됩니다.
  즉, _기존 코드가 닫혀 있고, 새로운 기능을 추가할 때만 열려 있는 구조가 됩니다._

### 팩토리 메서드 패턴의 단점

#### 1. 클래스 수 증가

- 팩토리 메서드 패턴에서는 각 제품에 대한 구체적인 제품에 대한 서브클래스가 필요합니다.
  `WindowsButton`과 `MacButton` 같은 구체적인 제품 클래스를 추가하고,
  `WindowsDialog`와 `MacDialog` 같은 구체적인 창조가 클래스를 만들어야 합니다.
  이는 클래스의 수가 증가하고, 관리해야 할 클래스가 많아져 코드가 복잡해질 수 있습니다.
  특히, 작은 프로젝트나 간단한 시스템에서는 불필요하게 클래스를 많이 생성해야 할 수 있습니다.

#### 2. 과도한 구조화

- 팩토리 메서드 패턴은 객체 생성을 위임하는 구조를 갖추기 위해 많은 클래스를 필요로 합니다.
  이로 인해 간단한 문제를 해결하려는 경우에도 불필요하게 구조화가 심해져 코드가 과도하게 복잡해질 수 있습니다.
  예를 들어, 간단한 버튼 생성만 필요한 경우에도 여러 클래스(상위, 하위 등)를 만들어야 하는 상황이 발생할 수 있습니다.

---

## # 팩토리 메서드 패턴의 단점 대체 방안

[# 목차](#-목차)

팩토리 메서드 패턴은 _클래스 수가 증가하거나, 구조가 과도하게 복잡해질 수 있다는 단점이 있습니다._
특히 단순한 객체 생성만 필요한 경우에는, 이 패턴이 오히려 불필요한 추상화와 클래스 설계로 인해 과하게 구조화된 코드를 유발할 수 있습니다.
이러한 단점을 보완하기 위해, 복잡한 상속 구조 없이 간단한 팩토리 함수를 통해 객체 생성 로직을 함수 내부로 캡슐화할 수 있습니다.

```javascript
function createButton(type) {
  switch (type) {
    case "windows":
      return new WindowsButton();
    case "mac":
      return new MacButton();
    default:
      throw new Error("Unsupported button type.");
  }
}
```

위의 팩토리 함수 `createButton(type)`은 인자로 받은 `type` 값에 따라 적절한 버튼 객체를 생성하여 반환합니다.
팩토리 함수 방식은 클래스를 계층적으로 분리할 필요 없이, 간단히 객체 생성을 관리할 수 있다는 장점이 있습니다.
객체 생성이 단순하고 제품 종류가 많지 않다면 팩토리 함수가 적합하며, 객체 생성 로직이 복잡하거나 확장이 필요하다면 팩토리 메서드 패턴이 용이합니다.
쉽게 말하면, _팩토리 메서드 패턴은 확장성에 강하고, 팩토리 함수는 간결함에 강합니다._

---

## # 팩토리 메서드 패턴의 사용 사례

[# 목차](#-목차)

### 1. UI 툴킷

- 운영체제(OS)나 사용자 테마(라이트/다크)에 따라 UI 구성 요소(Button, Checkbox 등)의 모양과 동작이 달라져야할 때 사용할 수 있습니다.
  예를 들어, `WindowsButton`, `MacButton`, `DarkThemeButton` 등 다양한 버튼 클래스를 운영체제나 테마에 맞게 생성할 때 유용합니다.
  하나의 인터페이스만 알고 있어도, 환경에 맞는 UI 컴포넌트를 유연하게 생성할 수 있습니다.

### 2. 게임 개발

- 캐릭터, 무기, 아이템, 스킬 등 다양한 게임 객체를 생성할 때, 생성 로직을 분리하고 싶을 때 사용할 수 있습니다.
  예를 들어, 플레이어가 직업을 선택하면, `WarriorCharacter`, `MageCharacter` 등 해당 직업에 맞는 캐릭터를 생성하고,
  새로운 캐릭터나 아이템 타입을 쉽게 추가할 수 있어 생성 방식이 복잡해져도 코드 분리로 관리가 용이합니다.

### 3. 로깅 시스템

- 로그를 콘솔에 출력할지, 파일에 저장할지, 혹은 클라우드로 전송할지 상황에 따라 달라질 때 사용할 수 있습니다.
  예를 들어, `ConsoleLogger`, `FileLogger`, `CloudLogger` 등을 상황에 따라 팩토리 메서드를 통해 구현하여,
  로깅 방식이 바뀌어도 기존 로깅 호출부는 변경하지 않아도 되므로 OCP(개방/패쇄 원칙)을 만족하며 유연하게 확장할 수 있습니다.

팩토리 메서드 패턴은 위의 사례뿐만 아니라,
동일한 인터페이스를 기반으로 다양한 객체를 상황에 맞게 생성해야 하는 경우에 모두 적용할 수 있습니다.
특히, 유지보수성과 확장성을 고려한 설계가 필요한 시스템에서 매우 유용하게 사용할 수 있습니다.

---

## # 마무리

[# 목차](#-목차)

팩토리 메서드 패턴은 객체 생성 로직을 하위 클래스에 위임함으로써,
_유지보수가 쉬운 구조와 확장 가능한 설계를 만드는 해주는 강력한 생성 패턴입니다._
특히, 변화가 많은 UI 요소, 게임 객체, 플러그인 구조, 로깅 시스템 등에서 큰 유연성과 재사용성을 발휘합니다.
물론, 클래스 수가 많아질 수 있다는 단점도 있지만, 복잡한 로직의 분리와 느슨한 결합을 통해 장기적으로는 더 안정적이고 확장할 수 있는 구조를 만듭니다.
핵심은 _'상위 클래스가 객체를 직접 생성하지 않고, 하위 클래스에게 생성을 위임한다.'_ 는 점입니다.
이를 통해 클라이언트는 어떤 객체가 생성되는지 몰라도 원하는 기능을 사용할 수 있으며,
변화에도 유연하게 대응할 수 있는 구조를 가질 수 있습니다.
상황에 따라 간단한 팩토리 함수로 대체할 수 있고, 복잡한 시스템이라면 팩토리 메서드 패턴을 통해 구조적인 설계를 고려해볼 수 있습니다.

_# references_
