---
title: Singleton Pattern
description: Purpose and Application of Singleton Pattern
category: Design Pattern
thumbnail: /image/singleton-pattern.jpg
createdAt: 2025-03-10
featured: false
---

---

## # 목차

- [# 싱글톤 패턴이란](#-싱글톤-패턴이란)
- [# 싱글톤 패턴의 자바스크립트 구현](#-싱글톤-패턴의-자바스크립트-구현)
- [# 싱글톤 패턴의 장점과 단전](#-싱글톤-패턴의-장점과-단점)
- [# 싱글톤 패턴의 단점 대체 방안](#-싱글톤-패턴의-단점-대체-방안)
- [# 싱글톤 패턴의 사용 사례](#-싱글톤-패턴의-사용-사례)
- [# 마무리](#-마무리)

---

## # 싱글톤 패턴이란

[# 목차](#-목차)

싱글톤 패턴<sup>(Singleton Pattern)</sup>은 디자인 패턴의 생성 패턴으로 분류되며,
객체지향 프로그래밍에서 _객체의 인스턴스가 오직 하나만 생성되도록 보장하는 디자인 패턴입니다._
이 패턴은 여러 객체가 같은 자원(데이터 베이스 연결, 설정 파일 등)을 공유해야 할 때 유용합니다.
싱글톤 패턴을 사용하면 애플리케이션 내에서 하나의 객체만 생성되어 일관된 상태를 유지하며,
생성된 _단 하나의 인스턴스를 공유하기 때문에 중복된 객체 생성 비용을 줄일 수 있지만 의존성은 높아집니다._

---

## # 싱글톤 패턴의 자바스크립트 구현

[# 목차](#-목차)

자바스크립트에서 싱글톤 패턴을 구현하는 방법은 여러 가지가 있습니다.
객체 리터럴 또는 Object 빌트인 객체를 통해 객체를 생성하면 다른 어떤 객체와도 같지 않기 때문에 구현할 수 있습니다.
다만, 가장 일반적인 방식은 클래스를 사용해 인스턴스를 지속적으로 관리하는 것입니다.

아래 코드의 Singleton 클래스는 인스턴스가 존재하지 않는 경우 최초 한 번만 인스턴스를 생성하고,
이후에는 동일한 인스턴스를 계속 반환하도록 참조 값을 고정하여 객체가 더 이상 생성되지 않고, 단 하나의 인스턴스를 공유하도록 구현된 기본 형식입니다.

```javascript
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }

    return Singleton.instance;
  }
}

const instanceA = new Singleton();
const instanceB = new Singleton();

console.log(instanceA === instanceB); // true
```

---

## # 싱글톤 패턴의 장점과 단점

[# 목차](#-목차)

### _싱글톤 패턴의 장점_

1. _전역 상태 관리_

- 싱글톤 패턴은 애플리케이션에서 하나의 인스턴스만 존재하므로, 상태를 전역적으로 관리할 수 있습니다.
  여러 객체나 모듈에서 동일한 인스턴스를 공유하면서 일관성 있는 상태를 유지할 수 있습니다.

2. _메모리 절약_

- 싱글톤 패턴은 인스턴스를 한 번만 생성하므로 불필요한 객체 생성에 대한 메모리 낭비를 줄일 수 있습니다.
  특히, 리소스를 많이 사용하는 객체에 대해 유용합니다.

4. _인스턴스 관리의 일관성_

- 하나의 인스턴스만 사용되므로, 해당 객체의 상태를 변경하는 코드가 여러 곳에 분포하는 것을 방지할 수 있습니다.

### _싱글톤 패턴의 단점_

1. _전역 상태 문제_

- 싱글톤 패턴은 전역에서 접근할 수 있는 상태를 관리하기 때문에, 애플리케이션 전역에 영향을 미칠 수 있습니다.
  이는 객체의 상태가 예기치 않게 변경될 수 있는 위험을 초래할 수 있습니다.
  여러 모듈이 동일한 인스턴스를 공유하므로 상태 변화가 의도치 않게 다른 모듈에 영향을 미칠 수 있습니다.

2. _단위 테스트 어려움_

- 싱글톤 인스턴스는 전역에서 공유되기 때문에 단위 테스트가 어려워질 수 있습니다.
  예를 들어, 특정 테스트에서 싱글톤의 상태를 수정하면 다른 테스트에 영향을 미칠 수 있기 때문에 단위별 테스트가 어렵습니다.

3. _유연성 부족_

- 싱글톤 패턴은 애플리케이션이 실행되는 동안 단 하나의 인스턴스만 제공하기 때문에, 유연성이 떨어집니다.
  예를 들어 싱글톤을 사용하는 클래스가 다른 클래스와 결합도가 높으면, 해당 클래스의 인스턴스를 변경하거나 교체하는 것이 매우 어렵습니다.

---

## # 싱글톤 패턴의 단점 대체 방안

[# 목차](#-목차)

싱글톤 패턴은 사용하기가 쉽고 실용적이지만 부족한 유연성으로 모듈 간의 결합을 강하게 만들 수 있다는 단점이 존재합니다.
이를 위해 의존성 주입<sup>(Dependency Injection)</sup>을 통해 모듈 간의 결합을 조금 더 느슨하게 만들어 해결할 수 있습니다.

> _의존성 주입 (Dependency Injection)_  
> 객체가 필요한 의존성을 외부에서 주입하는 방식입니다.
> 쉽게 말하면, 객체가 필요한 의존성(다른 객체)을 직접 생성하거나 관리하지 않고, 외부에서 독립적인 의존성을 주입해 주는 방식입니다.
> 독립적인 의존성을 주입하면 객체 간의 결합도가 낮아지고, 코드의 재사용성 및 테스트 용이성이 증가합니다.

```javascript
// 의존성 클래스
class Logger {
  log(message) {
    console.log(message);
  }
}

// 의존성 주입을 받지 않는 클래스
class UserService {
  constructor() {
    this.logger = new Logger(); // UserService 내부에서 Logger 인스턴스 생성
  }

  createUser(name) {
    this.logger.log(`User ${name} created`);
  }
}

// 사용
const userService = new UserService();
userService.createUser("John"); // User John created
```

위 코드는 "UserService" 클래스가 "Logger" 객체를 직접 생성하고 관리합니다.
즉, "UserService"는 "Logger"와 강하게 결합해 있어, "Logger"를 변경하거나 다른 로깅 시스템을 사용하려면 "UserService" 클래스 내부를 수정해야 합니다.
또한 단위 테스트 시 "Logger"의 동작을 교체하는 것이 어려우며 "UserService"는 항상 "Logger"를 사용하여 객체를 직접 생성하기 때문에,
다른 로깅 시스템으로의 변경이나 다양한 의존성 주입이 어렵습니다.

```javascript
// 의존성 클래스
class Logger {
  log(message) {
    console.log(message);
  }
}

// 의존성 주입을 받는 클래스
class UserService {
  constructor(logger) {
    this.logger = logger; // 생성자를 통해 의존성 주입
  }

  createUser(name) {
    this.logger.log(`User ${name} created`);
  }
}

// 의존성 주입
const logger = new Logger();
const userService = new UserService(logger); // Logger 인스턴스를 UserService에 주입

// 사용
userService.createUser("John");
```

UserService 클래스는 Logger 클래스에 의존하고 있습니다. Logger는 생성자 인자를 통해 UserService에 주입됩니다. 이제 UserService는 내부적으로 Logger를 사용하여 로그를 남깁니다.
의존성 주입을 통해 클래스는 자신이 사용하는 의존성을 외부에서 주입받아 코드의 유연성과 테스트 용이성을 높일 수 있습니다. 위의 코드 예시들처럼, 생성자, 세터, 메서드를 통해 의존성을 주입받는 방식은 애플리케이션의 구조를 더욱 명확하게 만들어줍니다.
생성자 주입은 의존성이 객체 생성 시 반드시 필요할 때 유용합니다.
세터 주입은 의존성이 선택적일 때 사용됩니다.
인터페이스 주입은 좀 더 구조적인 접근으로, 클래스가 인터페이스에 의존하게끔 할 수 있습니다.
위 방식들을 적절히 사용하여 애플리케이션의 유지보수성과 테스트 용이성을 개선할 수 있습니다.

---

## # 싱글톤 패턴의 사용 사례

[# 목차](#-목차)

---

## # 마무리

[# 목차](#-목차)

_# references_

- _[]()_
