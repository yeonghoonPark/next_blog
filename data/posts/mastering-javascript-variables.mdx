---
title: Mastering JavaScript Variables
description: Deep dive into `var`, `let`, and `const`
category: JavaScript
thumbnail: /image/mastering-javascript-variables.jpg
createdAt: 2024-08-31
featured: false
---

---

## # 목차

- [# 소개](#-소개)
- [# 변수란 무엇인가?](#-변수란-무엇인가)
- [# 변수 선언](#-변수-선언)
- [# var : legacy keyword](#-var--legacy-keyword)
- [# let : modern keyword](#-let--modern-keyword)
- [# const : constant keyword](#-const--constant-keyword)
- [# var, let, const 비교](#-var-let-const-비교)
- [# 마무리](#-마무리)

---

## # 소개

[# 목차](#-목차)

자바스크립트에서 `변수`<sup>`(variable)`</sup>는 데이터 저장과 동적 프로그래밍을 가능하게 하는 기본 요소입니다. 변수를 효과적으로 사용하는 방법을 이해하는 것은 깨끗하고 효율적인 코드를 작성하는 출발점이라 생각합니다. 이 글에서는 변수의 개념과 `var`, `let`, `const`의 차이점을 자세히 살펴보겠습니다.

---

## # 변수란 무엇인가?

[# 목차](#-목차)

사람은 두뇌에서 연산과 기억을 모두 담당하지만, 컴퓨터는 연산과 기억을 담당하는 부분이 각각 CPU와 메모리로 나뉘어져 있습니다. 메모리는 데이터나 값을 저장하기 위한 공간이며, 각 메모리 공간은 고유한 메모리 주소<sup>(memory address)</sup>를 가집니다. 이 주소를 통해 메모리의 특정 위치에 접근할 수 있습니다.

다음은 간단한 연산을 통해 컴퓨터가 데이터나 값을 어떤 형식으로 저장하는지 살펴보겠습니다.

```javascript
1 + 9; // 10
```

<div className="flex justify-between gap-2">
  <table>
    <thead>
      <tr>
        <th>메모리 주소</th>
        <th>메모리</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x00000000</td>
        <td>⋮</td>
      </tr>
      <tr>
        <td>0x000000A8</td>
        <td>1</td>
      </tr>
      <tr>
        <td>0x00002153</td>
        <td>9</td>
      </tr>
      <tr>
        <td>0x004B6701</td>
        <td>10</td>
      </tr>
      <tr>
        <td>0xFFFFFFFF</td>
        <td>⋮</td>
      </tr>
    </tbody>
  </table>
</div>

자바스크립트를 통해 컴퓨터에 1 + 9라는 식을 요청한다면 1과 9를 각 메모리에 저장하고 씨피유는 메모리에서 1과 9에 대한 + 연산을 수행합니다. 이 과정에서 얻은 결과 10은 메모리에 저장됩니다. 하지만 여기서 문제가 발생합니다. 프로그래머는 연산을 통해 얻은 결괏값인 10을 사용하거나 재사용할 수 없기 때문입니다. 10에 대한 고유한 메모리 주소(0x004B6701)가 존재하지만, 메모리 주소를 통해 값을 직접 변경하는 것은 오류를 초래할 수 있어 _자바스크립트는 프로그래머의 직접적인 메모리 제어를 허용하지 않습니다. 대신, 변수라는 메커니즘을 이용하여 결괏값을 저장하고 재사용할 수 있는 방법을 제공합니다._

다음은 자바스크립트의 변수를 통해 컴퓨터가 데이터나 값을 저장하는 형식을 살펴보겠습니다.

```javascript
var ten = 1 + 9; // 10
```

<div className="flex justify-between gap-2">
  <table>
    <thead>
      <tr>
        <th>메모리 주소</th>
        <th>메모리</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x00000000</td>
        <td>⋮</td>
      </tr>
      <tr>
        <td>0x000000A8</td>
        <td>1</td>
      </tr>
      <tr>
        <td>0x00002153</td>
        <td>9</td>
      </tr>
      <tr>
        <td>`변수명(식별자): ten` 👉 0x004B6701</td>
        <td>10</td>
      </tr>
      <tr>
        <td>0xFFFFFFFF</td>
        <td>⋮</td>
      </tr>
    </tbody>
  </table>
</div>

변수를 통해 위와 같은 연산을 수행한다면 "ten"은 변수명이 되고 동시에 식별자<sup>(identifier)</sup>가 됩니다. 식별자란 메모리의 특정 위치에 저장되고 있는 저장된 값을 참조할 수 있는 이름을 의미합니다. "ten"은 식별자로서 고유한 메모리 주소(0x004B6701)를 기억하고 있으며 프로그래머는 메모리에 직접 접근하지 않고 얻었던 결괏값을 저장하거나 재사용할 수 있게 됩니다. 이처럼 프로그래밍에서 _변수란 이러한 메모리 공간을 식별하기 위한 이름을 말하며, 데이터나 값을 저장하고 재사용하기 위한 역할을 합니다._ 즉, 변수는 메모리에서 특정 데이터를 저장하는 공간을 참조하는 이름을 의미합니다.

---

## # 변수 선언

[# 목차](#-목차)

변수 선언<sup>(variable declaration)</sup>은 말 그대로 변수를 정의하는 과정입니다. 변수를 선언하면 자바스크립트는 메모리에 값이나 데이터를 저장할 메모리 공간을 확보하며, 이 메모리 공간은 고유한 메모리 주소를 가지게 됩니다. 변수 선언 시에는 var, let, const 와 같은 키워드<sup>(keyword)</sup>를 사용하며, 변수 선언 과정은 다음의 3단계로 나눌 수 있습니다.

1. 선언 단계(declaration phase)  
   변수 이름을 정의하며, 호이스팅으로 선언문이 최상단으로 끌어올려집니다.

2. 초기화 단계(initialization phase)  
   메모리 공간을 확보하고, 처음으로 값을 초기화하는 단계입니다. 이때 초깃값은 undefined가 됩니다.

3. 할당 단계(assignment phase)  
   변수에 새로운 값을 할당하거나 기존 값을 변경하는 단계입니다.

자바스크립트는 위의 3단계를 거쳐 변수를 선언합니다. 그러나 _var, let, const 각 키워드는 이 3단계 과정에서 실행 시점과 방식에서 차이가 있습니다._ 다음 목차에서는 각 키워드의 배경과 특징, 그리고 변수 선언 시의 차이점을 자세히 살펴보겠습니다.

---

## # var : legacy keyword

[# 목차](#-목차)

var 키워드는 자바스크립트 초기 버전인 ES1에서 도입된 변수 선언 키워드로 ES5까지 변수를 선언할 수 있는 유일한 키워드였습니다. 여전히 유효하고 널지 지원되지만, 몇 가지 특징으로 인해 예상치 못한 버그를 초래할 수 있습니다.

1. 중복 선언 허용

_var는 동일한 스코프 내에서 중복 선언을 허용합니다._ 이는 변수 덮어쓰기<sup>(overwriting variables)</sup>를 초래하며 마지막으로 선언된 변수에 덮어써집니다. 이에 따라 이전에 할당한 값은 사라지게 되며, 이는 코드의 규모가 커질수록 어느 시점에 변수의 값이 변경되었는지 추적하기 힘든 상황을 초래합니다.

```javascript
// 1. 중복 선언 허용

var x = 10;
var x = 20; // 기존 x의 값이 10에서 20으로 변경됨

console.log(x); // 출력: 20
```

<br />

2. 함수 스코프(function level scope)

var는 함수 스코프를 가지고 있습니다. 이는 _선언된 함수 내에서만 지역 변수로 작용하고, 그 외에는 항상 전역 변수로 작용하게 됩니다._ 이는 블록<sup>(block)</sup>을 가진 키워드<sup>(if 문, for 문, while 문 등)</sup>에서는 지역 변수로 작동하지 않고 전역 변수로 공유되므로 의도치 않는 버그를 초래할 수 있습니다.

```javascript
// 2. 함수 스코프

var x = 10; // 전역 변수
var y = 10; // 전역 변수

function foo() {
  var x = 20; // 함수 내에서 선언되어 지역 변수로 작용함
}

if (true) {
  var y = 20; // 함수 내에서 선언되지 않아 전역 변수로 작용함
}

console.log(x); // 출력: 10
console.log(y); // 출력: 20
```

<br />

3. 변수 선언 과정

var의 경우 코드를 위에서 아래로 읽어나가며 실행하는 런-타임 이전에 선언 단계와 초기화 단계가 동시에 일어나고, 런-타임 때 할당 단계를 거치게 됩니다. 즉, 선언 단계에서 호이스팅과 동시에 초기화 단계를 거치기 때문에 메모리 공간을 확보하고 있으며, 이런 이유로 런-타임 때 값을 할당받기 전에도 참조할 수 있습니다. 이때 변수는 undefined를 반환합니다.

```javascript
// 3. 변수 선언 과정

// ↓ 실제 작성한 코드
console.log(x);

var x = 10;

console.log(x);

// ↓ 자바스크립트가 읽는 코드 (런-타임)
var x; // 변수 선언 및 초기화 단계

console.log(x); // 출력: undefined

x = 10; // 할당 단계

console.log(x); // 출력: 10
```

<br />

위와 같은 var 키워드의 특징들은 언뜻보면 유연하게 보이지만 여기에는 일반적인 함정과 문제점을 포함하고 있습니다. _특히 함수 스코프라는 특성은 예기치 않은 전역 변수를 남발할 수 있고, 선언 된 변수가 중첩 블록 내에서 의도치 않게 가려질 수도 있습니다._ 이는 디버깅과 코드의 흐름을 추적하기 어렵게 만들고 버그를 유발할 확률을 높힙니다.

---

## # let : modern keyword

[# 목차](#-목차)

let 키워드는 ES6에서 처음 도입된 새로운 변수 선언 키워드로 이전의 var 키워드와 관련된 많은 문제를 해결합니다. 현대 자바스크립트에서 변수 선언을 보다 예측할 수 있고 관리하기 쉽게 만들어 주는 이유를 살펴보겠습니다.

1. 중복 선언 금지

_let은 동일한 스코프 내에서 중복 선언을 금지합니다._ 중복 선언을 할 경우 문법 에러<sup>(syntax error)</sup>가 발생합니다. 이는 프로그래머의 실수를 미리 예방하고 변수를 추적하기 쉽게 만들어 줍니다.

```javascript
// 1. 중복 선언 금지

let x = 10;
let x = 20; // SyntaxError: Identifier 'x' has already been declared
```

<br />

2. 블록 스코프(block level scope)

let은 블록 스코프를 가지고 있습니다. 이는 _함수뿐만 아니라 블록을 가진 모든 키워드 안에서 선언될 경우, 항상 지역 변수로 작용합니다._ 즉, 블록 단위로 지역이 나뉩니다.

```javascript
// 2. 블록 스코프

let x = 10; // 전역 변수
let y = 10; // 전역 변수

function foo() {
  let x = 20; // { } 내에서 선언되어 지역 변수로 작용함
}

if (true) {
  let y = 20; // { } 내에서 선언되어 지역 변수로 작용함
}

console.log(x); // 출력: 10
console.log(y); // 출력: 10
```

<br />

3. 변수 선언 과정

let은 코드를 한 줄씩 읽어 내려가는 _런-타임 이전에 선언 단계만 거치며, 런-타임 때 초기화 단계와 할당 단계를 거치게 됩니다._ 런-타임 이전에는 호이스팅이 일어나고 자바스크립트에 식별자를 정의했지만 메모리 공간을 확보하지 못한 상태입니다. 런-타임이 되어야 초기화 단계를 통해 메모리 공간을 확보하고 할당 단계를 거칠 수 있습니다. 즉, 선언 단계와 초기화 단계가 런-타임 전후로 나뉩니다. 또한 메모리 공간을 확보하는 초기화 단계 없이는 메모리에 접근할 수 없기 때문에 변수에 접근하려 한다면 참조 에러가 발생합니다. 이처럼 _선언 단계부터 초기화 단계를 거치기 전까지 값을 참조할 수 없는 구간을 TDZ<sup>(Temporal Dead Zone)</sup>이라 합니다._

```javascript
// 3. 변수 선언 과정

// ↓ 실제 작성한 코드
console.log(x); // ReferenceError: Cannot access 'x' before initialization

let x = 10;

console.log(x);

// ↓ 자바스크립트가 읽는 코드 (런-타임)
console.log(x); // 초기화 단계를 거치지 않아 참조 에러 발생

let x; // 초기화 단계
x = 10; // 할당 단계

console.log(x);
```

<br />

let은 의도하지 않는 전역 변수를 방지하여 _지역과 전역의 구분점을 쉽고 명확하게 만듭니다._ 또한 스코프를 효율적으로 관리하여 변수 가림 문제와 의도치 않는 접근을 방지하여 프로그래머의 실수를 예방하도록 도와줍니다.

---

## # const : constant keyword

[# 목차](#-목차)

const 키워드는 let 키워드와 함께 ES6에 도입되었으며, _중복 선언 금지, 블록 스코프, TDZ를 가지는 점은 let과 동일 합니다._ 차이점이라면 const는 _참조가 변경되지 않아야 하는 변수를 선언하는데 사용된다는 점입니다._ 여기서 주의할 점은 변수가 원시 타입의 데이터라면 불변성을 유지하기 때문에 값을 바꿀 수 없지만, 참조 타입의 데이터일 경우 불변성을 유지하지 않아도 되기 때문에 값을 변경할 수 있습니다. 즉, _데이터 타입에 따라 값은 변경될 수 있으나 참조의 보장을 의미합니다._ 다음은 해당 키워드만 가지는 특징에 대해 살펴보겠습니다.

1. 재할당 금지

var와 let을 이용하여 선언된 변수는 재할당을 허용하지만, _const는 재할당을 금지합니다._ 만약 재할당을 시도할 경우 타입 에러<sup>(type error)</sup>가 발생합니다.

```javascript
// 1. 재할당 금지

let x = 10;
x = 20; // var와 let은 재할당이 가능함

const y = 100;
y = 200; // TypeError: Assignment to constant variable.
```

<br />

2. 변수 선언 과정

const는 런-타임 이전에 선언 단계를 거치고, 런-타임 때 초기화 단계를 거치는 과정은 let과 동일합니다. 하지만 _런-타임 때 초기화 단계 + 할당 단계를 반드시 거쳐야한다는 차이점을 가지고 있습니다._ 즉, 참조를 변경할 수 없기 때문에(재할당 금지) 초기화 단계에서 var, let과 다르게 자동으로 undefined가 할당되지 않으며 항상 값을 할당해야 합니다. 만약 값을 할당하지 않을 경우 문법 에러가 발생합니다.

```javascript
// 2. 변수 선언 과정

// ↓ 실제 작성한 코드
let x;
const y = 10
const z; // SyntaxError: Missing initializer in const declaration

// ↓ 자바스크립트가 읽는 코드 (런-타임)
let x; // 초기화 단계, undefined 할당
const y = 10; // 초기화 + 할당 단계, 10 할당
const z; // 초기화 단계, 할당 단계 부재로 인한 문법 에러 발생
```

<br />

const는 변수에 담긴 데이터 타입에 따라 값이 변하지 않는다고 보장되진 않지만 참조를 고정시키며, 이는 코드의 안정성과 명확성을 높힙니다. 의도하지 않는 재할당으로 인한 버그를 방지하고 코드의 동작을 예측하기 쉽게 만드는 장점이 있습니다. 또한 자바스크립트 엔진은 참조가 변하지 않는 다는 것을 알고 있기 때문에 특정 최적화를 수행할 수 있습니다. 물론 이점은 직접적인 성능을 체감하기 어렵지만 최적화 기회가 될 수 있습니다.

> 참조가 고정되지만, 값은 변할 수 있다?
>
> 참조가 고정된다는 의미는 변수가 메모리 주소를 참조(기억)한다는 의미입니다. 원시 타입 데이터는 변경 불가능한 값이라 하고 참조 타입 데이터는 변경할 수 있는 값이라고 합니다. 여기서 변경 불가능한 값, 변경할 수 있는 값에 대한 기준은 참조의 고정 여부가 기준입니다. 즉, _값을 변경할 때마다 참조를 변경해야 하는 값을 변경 불가능한 값(원시 타입)이라 하고 값을 변경할 때 참조를 변경하지 않아도 되는 값을 변경할 수 있는 값(참조 타입)이라고 합니다._

---

## # `var`, `let`, `const` 비교

[# 목차](#-목차)

<div className="flex justify-between gap-2">
  <table>
    <thead>
      <tr>
        <th></th>
        <th>var</th>
        <th>let</th>
        <th>const</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>중복 선언</td>
        <td>✅</td>
        <td>❌</td>
        <td>❌</td>
      </tr>
      <tr>
        <td>스코프</td>
        <td>함수 스코프</td>
        <td>블록 스코프</td>
        <td>블록 스코프</td>
      </tr>
      <tr>
        <td>재할당</td>
        <td>✅</td>
        <td>✅</td>
        <td>❌</td>
      </tr>
      <tr>
        <td>선언 과정</td>
        <td>(선언 + 초기화) → 할당</td>
        <td>선언 → 초기화 → 할당 </td>
        <td>선언 → (초기화 + 할당)</td>
      </tr>
    </tbody>
  </table>
</div>

- var는 중복 선언을 허용하지만, let과 const는 중복 선언을 허용하지 않습니다.
- var는 함수 스코프, let과 const는 블록 스코프를 가집니다.
- var와 let은 재할당이 가능하지만, const는 재할당이 불가능합니다.
- var는 런-타임 이전에 (선언 + 초기화) 단계가 동시에 일어나고, 런-타임에 할당 단계를 거칩니다.
- let은 런-타임 이전에 선언 단계만 거치고, 런-타임에 초기화 단계와 할당 단계를 거칩니다.
- const는 런-타임 이전에 선언 단계만 거치고, 런-타임에 (초기화 + 할당) 단계를 거칩니다.

---

## # 마무리

[# 목차](#-목차)

각 키워드를 이용해서 변수를 선언하는 방법이나 개념들을 어렴풋이 알고 있었지만, 글을 작성하면서 새롭고 희미한 부분들을 명확하게 알게 된 유익한 시간이었습니다. 프로그래밍하면서 셀 수 없이 했던 변수 선언임에도 불구하고 앞으로는 조금 더 멀리 보며 선언할 수 있다는 생각이 듭니다. 변수 선언의 개념에 대해 명확하지 않거나 변수를 처음 접하시는 분들에게 변수의 개념과 각 선언 키워드의 차이점을 이해하는 데 조금이나마 도움이 될 수 있다면 좋겠습니다.

_# references_

- _모던 자바스크립트 Deep Dive 저자 이웅모_
- _[var - JavaScript - MDN Web Docs - Mozilla](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/var)_
- _[let - JavaScript - MDN Web Docs - Mozilla](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/let)_
- _[const - JavaScript - MDN Web Docs - Mozilla](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/const)_
